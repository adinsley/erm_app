"use strict";

/* @flow */
var React = require("./react");

var _require = require("./util");

var omit = _require.omit;
var extend = _require.extend;

var classSet = require("classnames");

// a subset of react-bootstrap/Input, without any bootstrapisms
// most importantly it accepts value and label props and an onChange callback
var Field = React.createClass({
  displayName: "Field",

  propTypes: {
    type: React.PropTypes.string,
    label: React.PropTypes.any,
    validation: React.PropTypes.any,
    help: React.PropTypes.any,
    hint: React.PropTypes.any,
    groupClassName: React.PropTypes.string,
    fieldClassName: React.PropTypes.string,
    wrapperClassName: React.PropTypes.string,
    labelClassName: React.PropTypes.string,
    onChange: React.PropTypes.func
  },
  getInputDOMNode: function getInputDOMNode() {
    return this.refs.input.getDOMNode();
  },
  getValue: function getValue() {
    if (typeof this.props.type == "string") {
      return this.getInputDOMNode().value;
    } else throw new Error("Cannot use getValue without specifying input type.");
  },
  getChecked: function getChecked() {
    return Boolean(this.getInputDOMNode().checked);
  },
  renderInput: function renderInput() {
    var input = null;

    if (!this.props.type) {
      return this.props.children;
    }

    var propsForInput = extend(omit(this.props, "form", "name"), { ref: "input", key: "input" });

    switch (this.props.type) {
      case "select":
        input = React.DOM.select(extend({ children: this.props.children }, propsForInput));
        break;
      case "textarea":
        input = React.DOM.textarea(propsForInput);
        break;
      case "submit":
        input = React.DOM.input(extend({ type: "submit" }, propsForInput));
        break;
      default:
        input = React.DOM.input(propsForInput);
    }

    return input;
  },
  renderHint: function renderHint() {
    var hint = this.props.help || this.props.hint;
    return hint ? React.createElement(
      "span",
      { key: "hint", className: "field-hint" },
      hint
    ) : null;
  },
  renderErrorMessage: function renderErrorMessage() {
    var errorMessage = this.props.validation;
    return errorMessage ? React.createElement(
      "span",
      { key: "errorMessage", className: "field-error-message" },
      errorMessage
    ) : null;
  },
  renderWrapper: function renderWrapper(children) {
    return this.props.wrapperClassName ? React.createElement(
      "div",
      { className: this.props.wrapperClassName, key: "wrapper" },
      children
    ) : children;
  },
  renderLabel: function renderLabel(children) {
    return this.props.label ? React.createElement(
      "label",
      { htmlFor: this.props.id, className: this.props.labelClassName, key: "label" },
      children,
      this.props.label
    ) : children;
  },
  renderFieldWrapper: function renderFieldWrapper(children) {
    var fieldClassName = this.props.groupClassName || this.props.fieldClassName;
    var fieldClassSet = {
      "rff-field": true,
      "rff-field-with-errors": this.props.validation };
    if (fieldClassName) fieldClassSet[fieldClassName] = true;
    return React.createElement("div", { className: classSet(fieldClassSet), children: children });
  },
  render: function render() {
    return this.renderFieldWrapper([this.renderLabel(null), this.renderWrapper([this.renderInput(), this.renderHint(), this.renderErrorMessage()])]);
  }
});

module.exports = Field;