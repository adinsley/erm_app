"use strict";

var _prototypeProperties = function (child, staticProps, instanceProps) { if (staticProps) Object.defineProperties(child, staticProps); if (instanceProps) Object.defineProperties(child.prototype, instanceProps); };

var _get = function get(object, property, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc && desc.writable) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _inherits = function (subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) subClass.__proto__ = superClass; };

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

/* @flow */
var React = require("./react");

var cloneWithProps = require("./react").addons.cloneWithProps;

var StandardError = require("standard-error");

var _require = require("./util");

var updateIn = _require.updateIn;
var extend = _require.extend;

var Field = require("./field");
var isElement = React.isValidElement || React.isValidComponent;

function hasChildren(node) {
  return node && node.props && node.props.children;
}

function getType(node) {
  return node && node.type || node.constructor;
}

function isFieldProxy(node) {
  var type = getType(node);
  return type && type.isFieldProxy;
}

function isFormProxy(node) {
  var type = getType(node);
  return type && type.isFormProxy;
}

var NoChildrenError = (function (StandardError) {
  function NoChildrenError() {
    _classCallCheck(this, NoChildrenError);

    _get(Object.getPrototypeOf(NoChildrenError.prototype), "constructor", this).call(this, "form/fieldset without children not valid");
  }

  _inherits(NoChildrenError, StandardError);

  return NoChildrenError;
})(StandardError);

// recursive map over children and inject form prop
function getChildrenWithForm(node, form) {
  return React.Children.map(node.props.children, function (child) {
    if (!isElement(child) || typeof child == "string" || typeof child.props == "string" || child.props && typeof child.props.children == "string") {
      return child;
    }

    var updatedProps = {};

    if (isFormProxy(child)) {
      if (!hasChildren(child)) throw new NoChildrenError();
      // stop recursion, just inject form parentForm
      updatedProps.parentForm = form;
    } else {
      if (isFieldProxy(child)) {
        updatedProps.form = form;
      }
      // recurse to update grandchildren
      updatedProps.children = getChildrenWithForm(child, form);
    }

    return cloneWithProps(child, updatedProps);
  });
}

var Form = (function () {
  function Form(component, parentForm) {
    _classCallCheck(this, Form);

    this.component = component;
    if (parentForm instanceof Form) {
      // a nested form fieldset, delegates to the top level form
      this.acquireOptsFromParentForm(component, parentForm);
    } else {
      // the top level form
      this.acquireOptsFromComponent(component);
    }
  }

  _prototypeProperties(Form, {
    getValueFromComponent: {
      value: function getValueFromComponent(component) {
        if (component.props.value instanceof Object) {
          return component.props.value;
        } else if (component.props["for"] instanceof Object) {
          return component.props["for"];
        } else {
          return null;
        }
      },
      writable: true,
      configurable: true
    },
    getNameFromComponent: {
      value: function getNameFromComponent(component) {
        if (typeof component.props.name == "string" || typeof component.props.name == "number") {
          return component.props.name;
        } else if (typeof component.props["for"] == "string") {
          return component.props["for"];
        } else {
          return null;
        }
      },
      writable: true,
      configurable: true
    }
  }, {
    getChildren: {
      value: function getChildren() {
        if (this.component.props.children) {
          // traverse component children and inject form prop
          return getChildrenWithForm(this.component, this);
        } else {
          throw new NoChildrenError();
        }
      },
      writable: true,
      configurable: true
    },
    applyUpdate: {
      value: function applyUpdate(value, path) {
        if (this.parentForm instanceof Form) {
          this.parentForm.applyUpdate(value, path);
          return;
        }

        if (this.onChange instanceof Function) {
          this.onChange(updateIn(this.value, path, value));
        }
      },
      writable: true,
      configurable: true
    },
    acquireOptsFromComponent: {
      value: function acquireOptsFromComponent(component) {
        var value = Form.getValueFromComponent(component);

        this.value = value || {};
        this.path = [];
        this.onChange = component.props.onChange;
        this.labels = component.props.labels;
        this.externalValidation = component.props.externalValidation;
        this.hints = component.props.hints;

        this.fieldComponent = component.props.fieldComponent || Field;
      },
      writable: true,
      configurable: true
    },
    acquireOptsFromParentForm: {
      value: function acquireOptsFromParentForm(component, parentForm) {
        var name = Form.getNameFromComponent(component);
        if (parentForm instanceof Form && name == null) throw new Error("name required when parentForm provided");
        if (!(parentForm instanceof Form)) throw new Error("invalid parentForm");
        this.parentForm = parentForm;
        this.path = parentForm.path.concat(name);

        this.value = parentForm.getValueFor(name) || {};
        this.labels = parentForm.getLabelFor(name);
        this.externalValidation = parentForm.getExternalValidationFor(name);
        this.hints = parentForm.getHintsFor(name);

        this.fieldComponent = component.props.fieldComponent || parentForm.fieldComponent || Field;
      },
      writable: true,
      configurable: true
    },
    getValueFor: {
      value: function getValueFor(name) {
        return this.value[name];
      },
      writable: true,
      configurable: true
    },
    getLabelFor: {
      value: function getLabelFor(name) {
        return this.labels instanceof Object ? this.labels[name] : null;
      },
      writable: true,
      configurable: true
    },
    getExternalValidationFor: {
      value: function getExternalValidationFor(name) {
        return this.externalValidation instanceof Object ? this.externalValidation[name] : null;
      },
      writable: true,
      configurable: true
    },
    getHintsFor: {
      value: function getHintsFor(name) {
        return this.hints instanceof Object ? this.hints[name] : null;
      },
      writable: true,
      configurable: true
    }
  });

  return Form;
})();

module.exports = Form;